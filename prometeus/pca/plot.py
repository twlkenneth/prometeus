from typing import Literal, Optional

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import ipywidgets as widgets

from bioinfokit.visuz import cluster
from sklearn.decomposition import PCA

from prometeus.utils import *
from .analyzer import PCAnalyzer
from .._base import CUTOFF_METHOD, BasePlot

__all__ = ['PCAPlot']


class PCAPlot(PCAnalyzer, BasePlot):
    def __init__(self, df: pd.DataFrame, clustered_labels: Optional[pd.Series] = None):
        super().__init__(df)
        self.clustered_labels = self._validate_clusters_data(clustered_labels)

    def generate_graphs(self, by: CUTOFF_METHOD, threshold: float = 0.8, n_components: Optional[int] = None,
                        is_filter: bool = False) -> widgets.Tab:
        """
        Create tabs in jupyter notebook and saves graphs in directory

        :param threshold:
            Percentage of variance explained, default 80%
        :param n_components:
            Number of principal components. If None will autogenerated using PCAnalyzer Library, else overwrite.
        :param is_filter:
            If False will show all PCA loadings heatmap. If True, will only show attributes with cells > 0.55.
        """
        _components = self._get_components(by, threshold) if n_components is None else n_components
        pca_loadings = self.get_loadings(by, threshold, n_components, is_filter).drop('highest_loading',axis=1).round(3)
        self.plot_biplot('2D')
        self.plot_biplot('3D')

        res = {
            'Cutoff Plots': [self.plot_cum_variance(threshold), self.scree_plot],
            'PCA Loading Heatmap': [self.plot_loading_heatmap(pca_loadings),
                                    self.generate_pca_loadings_summary_table(pca_loadings)],
            'Clusters Decision Plot': [self.plot_elbow(_components),
                                       self.plot_silhouette(_components)] if self.clustered_labels is not None else None,
            'Scatter Plots': [self.scatter_2d, self.scatter_3d,
                              self.generate_top_3_pca_scores_table(_components)]
                              if self.clustered_labels is not None else None,
            }
        return create_tabs_widgets(res)

    def plot_cum_variance(self, threshold: float) ->  go.Figure:
        """
        Cummulative explanatory variance plot

        :param threshold:
            Percentage of variance explanined, default 80%
        """
        x = np.arange(1, self.df.shape[1] +1, step=1)
        y = self._get_cum_variance()

        return self._plot_cum_variance(threshold, x, y)

    def plot_biplot(self, type: Literal['2D', '3D']):
        """ 2D or 3D bi plot """
        pca = self.pca
        loadings = pca.components_
        pca_scores = PCA().fit_transform(self.df)
        if type == '2D':
            cluster.biplot(cscore=pca_scores, loadings=loadings, labels=self.df.columns.values,
                           var1=round(pca.explained_variance_ratio_[0] * 100, 2),
                           var2=round(pca.explained_variance_ratio_[1] * 100, 2))
            print("2D bi-plot Picture saved at same directory!")
        elif type == '3D':
            cluster.biplot(cscore=pca_scores, loadings=loadings, labels=self.df.columns.values,
                           var1=round(pca.explained_variance_ratio_[0] * 100, 2),
                           var2=round(pca.explained_variance_ratio_[1] * 100, 2),
                           var3=round(pca.explained_variance_ratio_[2] * 100, 2))
            print("3D bi-plot Picture saved at same directory!")

    def plot_elbow(self, n_components: int) -> go.Figure:
        """ Elbow method plot """
        clusters_range, inertias = self._get_elbow_info(n_components)

        return self._plot_elbow(clusters_range, inertias)

    def plot_silhouette(self, n_components: int) -> go.Figure:
        """ Silhouette plot """
        principalDf = self._get_principal_df(n_components)
        clusters_range, score = self._generate_silhouette_score(n_components, principalDf)

        return self._plot_silhouette(clusters_range, score)

    @property
    def scree_plot(self):
        """ Scree Plot """
        pca = self.pca
        num_pc = pca.n_features_

        pc_list = ["PC" + str(i) for i in list(range(1, num_pc + 1))]

        return self._plot_scree(pc_list, pca.explained_variance_)

    def plot_loading_heatmap(self, pca_loadings: pd.DataFrame) ->  go.Figure:
        """
        PCA loading heatmap visualization

        :param pca_loadings:
            PCA loadings dataframe input. Can be generated from PCAnalyzer
        """
        return self._plot_loading_heatmap(pca_loadings)

    def generate_pca_loadings_summary_table(self, pca_loadings: pd.DataFrame) -> pd.DataFrame:
        """ Get summary table for PCA loadings """
        return self._generate_loadings_summary_table(pca_loadings)

    @property
    def scatter_3d(self) ->  go.Figure:
        """ 3D scatter plot for clustered data """
        pca = PCA(n_components=3)
        components = pca.fit_transform(self.df)
        total_var = pca.explained_variance_ratio_.sum() * 100
        return self._plot_scatter_3d(components, self.clustered_labels.cluster, total_var)

    @property
    def scatter_2d(self) ->  go.Figure:
        """ 2D scatter plot for clustered data """
        pca = PCA(n_components=2)
        components = pca.fit_transform(self.df)
        total_var = pca.explained_variance_ratio_.sum() * 100
        return self._plot_scatter_2d(components, self.clustered_labels.cluster, total_var)

    def generate_top_3_pca_scores_table(self, n_components: int = None) -> pd.DataFrame:
        """
        Get summary table for top 3 PCA scores according to clusters

        :param n_components:
            Number of principal components. If None will autogenerated using PCAnalyzer Library, else overwrite.
        """
        return self._generate_scores_table(self._get_principal_df(n_components), self.clustered_labels)
